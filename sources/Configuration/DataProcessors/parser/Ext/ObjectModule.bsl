перем СписокСобытий;
перем владелец;
Перем ПараметрыРаботы;
перем id;
перем define;

функция Модификатор()
	возврат ПараметрыРаботы.Модификатор;
КонецФункции

Функция getid()
	id = id + 1;
	return id;
КонецФункции



Функция parseText(data) экспорт
	возврат РазобратьТекст(data);
КонецФункции

Функция РазобратьТекст(Данные) экспорт
	если не Данные.Свойство("Текст") тогда
		ВызватьИсключение "Нет обязательного поля Текст";
	КонецЕсли;
	если не Данные.Свойство("Автомат") тогда
		ВызватьИсключение "Нет обязательного поля Автомат";
	КонецЕсли;
	если не Данные.Свойство("Параметры") тогда
		Данные.Вставить("Параметры",новый Структура);
	КонецЕсли;
	
	ПараметрыРаботы = новый Структура;
	УстановитьПараметр(Данные.Параметры,"Оптимизировать",Ложь);
	УстановитьПараметр(Данные.Параметры,"Отладка",Ложь);
	УстановитьПараметр(Данные.Параметры,"СкрыватьСимволы",Ложь);
	УстановитьПараметр(Данные.Параметры,"Модификатор","lxm");
	УстановитьПараметр(Данные.Параметры,"СохранятьКомментарии",Ложь);
	
	Возврат РазобратьСтрокуАвтоматом(Данные.Текст,Данные.Автомат);
КонецФункции


Процедура УстановитьПараметр(Параметры,Имя,Умолчание)
	Значение = Неопределено;
	Если Параметры.Свойство(Имя,Значение) тогда
		ПараметрыРаботы.Вставить(Имя,Значение);
	иначе
		ПараметрыРаботы.Вставить(Имя,Умолчание);
	КонецЕсли;	
КонецПроцедуры




Функция ПрочитатьСтроку(ВходящийМассив, ТекущаяПозиция, СтрокаЧтения,	КолонкаЧтения, КоличествоСимволов) 
	СтрокаВозврата = "";
	РазмерМассива = ВходящийМассив.Count()-1;
	Для i = 1 to КоличествоСимволов Цикл
		Если (ТекущаяПозиция <= РазмерМассива) Тогда
			Если (ВходящийМассив[ТекущаяПозиция] = КодСимвола(Символы.CR)) Тогда
				Если ТекущаяПозиция + 1 < РазмерМассива
					И  ВходящийМассив[ТекущаяПозиция + 1] <> КодСимвола(Символы.LF)  Тогда
					СтрокаЧтения = СтрокаЧтения + 1;
					КолонкаЧтения = 0;
				КонецЕсли;
			КонецЕсли;
			Если ВходящийМассив[ТекущаяПозиция] = КодСимвола(Символы.LF) Тогда
				СтрокаЧтения = СтрокаЧтения + 1;
				КолонкаЧтения = 0;
			КонецЕсли;
			СтрокаВозврата = СтрокаВозврата + Символ(ВходящийМассив[ТекущаяПозиция]);
			ТекущаяПозиция = ТекущаяПозиция + 1;
			КолонкаЧтения = КолонкаЧтения + 1;
		КонецЕсли;
	КонецЦикла;
	Возврат СтрокаВозврата;
КонецФункции

Функция ПолучитьТокен(СтруктураГраматики, МассивРазбора, ТекущаяПозиция, СтрокаЧтения, КолонкаЧтения, СимволРазбора)
	
	РазмерМассива = МассивРазбора.Количество()-1;
	Если (ТекущаяПозиция >= РазмерМассива ) Тогда
		СимволРазбора = 0;
		Возврат Undefined;
	КонецЕсли;
	
	ИндексDFA = СтруктураГраматики.Сканер.Старт;
	КоличествоСимволов = 0;
	ДопустимоеКоличествоСимволов = 0;
	НайденыйИндекс = -1;
	Пока (ТекущаяПозиция + КоличествоСимволов <= РазмерМассива) Цикл
		Если (СтруктураГраматики.Сканер.Таблица[ИндексDFA].ИндексСимвола >= 0) Тогда
			НайденыйИндекс = ИндексDFA;
			ДопустимоеКоличествоСимволов = КоличествоСимволов;
		КонецЕсли;
		
		ВсегоТаблиц =  СтруктураГраматики.Сканер.Таблица[ИндексDFA].Коды.Количество(); 
		ДостигнутыйИндекс = 999999;
		Если ВсегоТаблиц > 0 Тогда
			АнализируемыйКод = МассивРазбора[ТекущаяПозиция + КоличествоСимволов];
			Для ДостигнутыйИндекс = 0 to ВсегоТаблиц-1 Цикл
				Состояние = СтруктураГраматики.Сканер.Таблица[ИндексDFA].Коды[ДостигнутыйИндекс];
				Если Состояние.Количество() = 0 Тогда
					Продолжить;
				КонецЕсли; 
				
				CharacterSet = СтруктураГраматики.ТаблицаСимволов[Состояние.ИндексТаблицыСимволов].Коды;
				Если CharacterSet <> Undefined Тогда
					Если CharacterSet.Find(АнализируемыйКод) <> Undefined Тогда
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли; 
		Если (ДостигнутыйИндекс >= ВсегоТаблиц) Тогда 
			Прервать; 
		КонецЕсли;
		ИндексDFA = СтруктураГраматики.Сканер.Таблица[ИндексDFA].Коды[ДостигнутыйИндекс].СледующееСостояние;
		КоличествоСимволов = КоличествоСимволов + 1;
	КонецЦикла;

	Если (СтруктураГраматики.Сканер.Таблица[ИндексDFA].ИндексСимвола >= 0) Тогда
		СимволРазбора = СтруктураГраматики.Сканер.Таблица[ИндексDFA].ИндексСимвола;
		Возврат ПрочитатьСтроку(МассивРазбора,ТекущаяПозиция,СтрокаЧтения,КолонкаЧтения,КоличествоСимволов);
	КонецЕсли;

	Если (НайденыйИндекс >= 0) Тогда
		СимволРазбора = СтруктураГраматики.Сканер.Таблица[НайденыйИндекс].ИндексСимвола;
		Возврат ПрочитатьСтроку(МассивРазбора,ТекущаяПозиция,СтрокаЧтения,КолонкаЧтения,ДопустимоеКоличествоСимволов);
	КонецЕсли;

	СимволРазбора = 0;
	Возврат ПрочитатьСтроку(МассивРазбора,ТекущаяПозиция,СтрокаЧтения,КолонкаЧтения,1);
КонецФункции


Функция ОбработатьУзелТокена( СтруктураГраматики,
	LalrState,
	TokenStack,
	InputToken,
	Оптимизировать,
	Отладка)
	var PopToken;
	var Reduction;
	var Action;
	var Rule;
	var i;
	
	Action = 0;
	Пока (Action <СтруктураГраматики.Переходы.Таблица[LalrState].КоличествоСимволов) Цикл
		Если (СтруктураГраматики.Переходы.Таблица[LalrState].Коды[Action].Индекс = InputToken.Token.СимволРазбора) Тогда
			Прервать;
		КонецЕсли;
		Action = Action+1;
	КонецЦикла;
	
	Если (Action >= СтруктураГраматики.Переходы.Таблица[LalrState].КоличествоСимволов) Тогда
		message("Неожиданный токен '"+InputToken.Token.Data+"' Строка "+format(InputToken.Token.СтрокаТокена,"ЧГ=") + " Колонка "+format(InputToken.Token.КолонкаТокена,"ЧГ="));
		Если (Отладка > 0) Тогда
			message("LALR Syntax error: symbol "+InputToken.Token.СимволРазбора+" not found in LALR table "+LalrState);
		КонецЕсли;
		Возврат define.LALRSYNTAXERROR;
	КонецЕсли;
	
	Если (СтруктураГраматики.Переходы.Таблица[LalrState].Коды[Action].Действие = define.ACTIONACCEPT) Тогда
		Если (Отладка > 0) Тогда
			message("LALR Accept: Target="+СтруктураГраматики.Переходы.Таблица[LalrState].Коды[Action].Значение);
		КонецЕсли;
		Возврат define.LALRACCEPT;
	КонецЕсли;
	
	Если (СтруктураГраматики.Переходы.Таблица[LalrState].Коды[Action].Действие= define.ACTIONSHIFT) Тогда
		LalrState =СтруктураГраматики.Переходы.Таблица[LalrState].Коды[Action].Значение;
		Если (Отладка > 0) Тогда
			message("LALR Shift: Lalr="+LalrState);
		КонецЕсли;
		Возврат define.LALRSHIFT;
	КонецЕсли;
	
	Если (СтруктураГраматики.Переходы.Таблица[LalrState].Коды[Action].Действие = define.ACTIONGOTO) Тогда
		LalrState = СтруктураГраматики.Переходы.Таблица[LalrState].Коды[Action].Значение;
		Если (Отладка > 0) Тогда
			message("LALR Goto: Lalr="+LalrState);
		КонецЕсли;
		Возврат define.LALRGOTO;
	КонецЕсли;
	
	Rule = СтруктураГраматики.Переходы.Таблица[LalrState].Коды[Action].Значение;
	Если (Отладка > 0) Тогда
		message("LALR Reduce: Lalr="+LalrState+" TargetRule="+СтруктураГраматики.Символы[СтруктураГраматики.Правила[Rule].ИндексНетерминал].Имя+"["+СтруктураГраматики.Правила[Rule].ИндексНетерминал+"] => "+СтруктураГраматики.Правила[Rule].Описание);
	КонецЕсли;
	
	Если 	Оптимизировать  
		И СтруктураГраматики.Правила[Rule].КоличествоСимволов = 1 
		И СтруктураГраматики.Символы[СтруктураГраматики.Правила[Rule].Символы[0]].Тип = define.SYMBOLNONTERMINAL Тогда
		Если (Отладка > 0) Тогда
			message("LALR TrimReduction.");
		КонецЕсли;
		PopToken = TokenStack;
		TokenStack = PopToken.СледующийТокен;
		LalrState = PopToken.СостояниеРазбора;
		PopToken.Token.СимволРазбора = СтруктураГраматики.Правила[Rule].ИндексНетерминал;
		ОбработатьУзелТокена(СтруктураГраматики,LalrState,TokenStack,PopToken,Оптимизировать,Отладка);
		PopToken.СледующийТокен = TokenStack;
		TokenStack = PopToken;
		InputToken.СостояниеРазбора = LalrState;
		Возврат ОбработатьУзелТокена(СтруктураГраматики,LalrState,TokenStack,InputToken,Оптимизировать,Отладка);
	КонецЕсли;
	
	Reduction = new Structure("Token,СостояниеРазбора,СледующийТокен",Undefined,LalrState,Undefined);
	Reduction.Token = new Structure("ReductionRule,Tokens,СимволРазбора,Data,СтрокаТокена,КолонкаТокена");
	Reduction.Token.ReductionRule = Rule;
	Reduction.Token.СимволРазбора = СтруктураГраматики.Правила[Rule].ИндексНетерминал;
	Reduction.Token.Data = Undefined;
	Reduction.Token.СтрокаТокена = InputToken.Token.СтрокаТокена;
	Reduction.Token.КолонкаТокена = InputToken.Token.КолонкаТокена;
	Reduction.Token.Tokens = new Array;
	Reduction.СостояниеРазбора = LalrState;
	Reduction.СледующийТокен = Undefined;
	
	Для i = -СтруктураГраматики.Правила[Rule].КоличествоСимволов to -1 Цикл
		PopToken = TokenStack;
		TokenStack = PopToken.СледующийТокен;
		PopToken.СледующийТокен = Undefined;
		Если (Отладка > 0) Тогда
			Если (PopToken.Token.Data <> Undefined) Тогда
				Message(" + СимволРазбора="+СтруктураГраматики.Символы[PopToken.Token.СимволРазбора].Имя+"["+PopToken.Token.СимволРазбора+"] RuleСимволРазбора="+СтруктураГраматики.Символы[СтруктураГраматики.правила[Rule].Символы[(-i)-1]].Имя+"["+СтруктураГраматики.правила[Rule].Символы[(-i)-1]+"] Value='"+PopToken.Token.Data+"' Lalr="+PopToken.СостояниеРазбора);
			else
				Message(" + СимволРазбора="+СтруктураГраматики.Символы[PopToken.Token.СимволРазбора].Имя+"["+PopToken.Token.СимволРазбора+"] RuleСимволРазбора="+СтруктураГраматики.Символы[СтруктураГраматики.правила[Rule].Символы[(-i)-1]].Имя+"["+СтруктураГраматики.правила[Rule].Символы[(-i)-1]+"] Value='"+PopToken.Token.Data+"' Lalr="+PopToken.СостояниеРазбора);
			КонецЕсли;
		КонецЕсли;
		Reduction.Token.Tokens.insert((-i) - 1, PopToken.Token);
		LalrState = PopToken.СостояниеРазбора;
		Reduction.СостояниеРазбора = PopToken.СостояниеРазбора;
		Reduction.Token.СтрокаТокена = PopToken.Token.СтрокаТокена;
		Reduction.Token.КолонкаТокена = PopToken.Token.КолонкаТокена;
	КонецЦикла;
	
	Если (Отладка > 0) Тогда
		message("Calling Lalr 1: Lalr="+LalrState+" СимволРазбора="+СтруктураГраматики.Символы[СтруктураГраматики.Правила[Rule].ИндексНетерминал].Имя+"["+СтруктураГраматики.Правила[Rule].ИндексНетерминал+"]");
	КонецЕсли;
	ОбработатьУзелТокена(СтруктураГраматики,LalrState,TokenStack,Reduction,Оптимизировать,Отладка);
	
	Reduction.СледующийТокен = TokenStack;
	TokenStack = Reduction;
	
	InputToken.СостояниеРазбора = LalrState;
	
	Если (Отладка > 0) Тогда
		message("Calling Lalr 2: Lalr="+LalrState+" СимволРазбора="+СтруктураГраматики.Символы[InputToken.Token.СимволРазбора].Имя+"["+InputToken.Token.СимволРазбора+"]");
	КонецЕсли;
	
	Возврат(ОбработатьУзелТокена(СтруктураГраматики,LalrState,TokenStack,InputToken,Оптимизировать,Отладка));
КонецФункции



функция Разобрать(СтруктураГраматики,МассивРазбора,КоличествоСимволов,Оптимизировать,Отладка,Токен)
	Перем СостояниеРазбора; 
	Перем СтекТокенов; 
	Перем Work; 
	Перем ТекущийСимвол; 
	Перем СтрокаТокена; 
	Перем КолонкаТокена;
	Перем Комментарий; 
	Перем Result; 

	СостояниеРазбора = СтруктураГраматики.Переходы.Старт;
	СтекТокенов = Неопределено;
	ТекущийСимвол = 0;
	СтрокаТокена = 0;
	КолонкаТокена = 0;
	Комментарий = 0;
	Токен = Неопределено;
	СтрокаКомментария = "";
	

	Если (МассивРазбора = Неопределено or МассивРазбора.Количество() = 0) Тогда
		Возврат СтруктураГраматики.define.PARSEACCEPT;
	КонецЕсли;

	пока истина цикл

		ТекТокен = новый Структура("type,Token,СостояниеРазбора,СледующийТокен",Неопределено,СостояниеРазбора,Неопределено);
		ТекТокен.Token = new Structure("type,ReductionRule,Tokens,СимволРазбора,Data,СтрокаТокена,КолонкаТокена,СтрокаКомментария");
		ТекТокен.Token.ReductionRule = -1;
		ТекТокен.type	= "tokenStackStruct";
		ТекТокен.Token.type	= "tokenStruct";
		ТекТокен.Token.Tokens = Неопределено;
		ТекТокен.Token.СтрокаТокена = СтрокаТокена;
		ТекТокен.Token.КолонкаТокена = КолонкаТокена;
		ТекТокен.Token.Data = ПолучитьТокен(СтруктураГраматики,МассивРазбора,ТекущийСимвол,СтрокаТокена,КолонкаТокена,ТекТокен.Token.СимволРазбора);
		ТекТокен.Token.СтрокаКомментария = СтрокаКомментария;
		Если (Комментарий > 0) Тогда
			Если (СтруктураГраматики.Символы[ТекТокен.Token.СимволРазбора].Тип = define.SYMBOLCOMMENTSTART) Тогда
				ТекТокен.СледующийТокен = СтекТокенов;
				СтекТокенов = Work;
				Комментарий = Комментарий + 1;
				continue;
			КонецЕсли;
			
			Если (СтруктураГраматики.Символы[ТекТокен.Token.СимволРазбора].Тип = define.SYMBOLCOMMENTEND) Тогда
				Work = СтекТокенов;
				СтекТокенов = ТекТокен.СледующийТокен;
				Комментарий = Комментарий - 1;
				continue;
			КонецЕсли;
			
			Если (СтруктураГраматики.Символы[ТекТокен.Token.СимволРазбора].Тип = define.SYMBOLEOF) Тогда
				Токен = СтекТокенов.Token;
				Возврат define.PARSECOMMENTERROR;
			КонецЕсли;

			continue;
		КонецЕсли;
		
		Если (СтруктураГраматики.Символы[ТекТокен.Token.СимволРазбора].Тип = define.SYMBOLCOMMENTSTART) Тогда
			Если (Отладка > 0) Тогда Message("Parse: skipping comment."); КонецЕсли;
			// Push the Token on the СтекТокенов to keep track of line+column.
			ТекТокен.СледующийТокен = СтекТокенов;
			СтекТокенов = Work;
			Комментарий = Комментарий + 1;
			continue;
		КонецЕсли;

		Если (СтруктураГраматики.Символы[ТекТокен.Token.СимволРазбора].Тип = define.SYMBOLCOMMENTLINE) Тогда
			СтрокаКомментария = "";
			
			Пока ТекущийСимвол < КоличествоСимволов И
				МассивРазбора[ТекущийСимвол] <> КодСимвола(Символы.CR) И
				МассивРазбора[ТекущийСимвол] <> КодСимвола(Символы.LF) Цикл
				СтрокаКомментария = СтрокаКомментария + Символ(МассивРазбора[ТекущийСимвол]);
				ТекущийСимвол = ТекущийСимвол + 1;
			КонецЦикла;
			Если ТекущийСимвол < КоличествоСимволов И
				МассивРазбора[ТекущийСимвол] = КодСимвола(Символы.LF) Тогда
				ТекущийСимвол = ТекущийСимвол + 1;
			КонецЕсли;

			Если ТекущийСимвол < КоличествоСимволов И
				МассивРазбора[ТекущийСимвол] = КодСимвола(Символы.CR) Тогда
				ТекущийСимвол = ТекущийСимвол + 1;
			КонецЕсли;
			СтрокаТокена = СтрокаТокена + 1;
			КолонкаТокена = 1;
			continue;
		КонецЕсли;
		
		// If parse error Тогда exit.
		Если (СтруктураГраматики.Символы[ТекТокен.Token.СимволРазбора].Тип = define.SYMBOLERROR) Тогда
			message("Error: Syntax error at (СтрокаТокена = "+ТекТокен.Token.СтрокаТокена+", column = "+ТекТокен.Token.КолонкаТокена+").");
			Возврат define.PARSELEXICALERROR;
		КонецЕсли;
		
		// Ignore whitespace.
		Если (СтруктураГраматики.Символы[ТекТокен.Token.СимволРазбора].Тип = define.SYMBOLWHITESPACE) Тогда
			continue;
		КонецЕсли;
		
		// The tokenizer should never return a non-terminal symbol.
		Если (СтруктураГраматики.Символы[ТекТокен.Token.СимволРазбора].Тип = define.SYMBOLNONTERMINAL) Тогда
			Если (Отладка > 0) Тогда
				message("Error: tokenizer Возвратed SYMBOLNONTERMINAL '"+ТекТокен.Token.Data+"'.");
			КонецЕсли;
			Возврат define.PARSETOKENERROR;
		КонецЕсли;
		
		Если (Отладка > 0) Тогда
			message("Token Read: Lalr="+СостояниеРазбора+" СимволРазбора="+СтруктураГраматики.Символы[ТекТокен.Token.СимволРазбора].Имя+"["+ТекТокен.Token.СимволРазбора+"] Value='"+ТекТокен.Token.Data+"' ("+ТекТокен.Token.СтрокаТокена+","+ТекТокен.Token.КолонкаТокена+")");
		КонецЕсли;
		ТекТокен.СостояниеРазбора = СостояниеРазбора;
		// Feed the СимволРазбора to the LALR state machine. It can Цикл several things, such as wind back И iteratively call itself.
		Result = ОбработатьУзелТокена(СтруктураГраматики,СостояниеРазбора,СтекТокенов,ТекТокен,Оптимизировать,Отладка);
		
		// If out of memory Тогда exit.
		Если (Result = define.LALRMEMORYERROR) Тогда
			Возврат define.PARSEMEMORYERROR;
		КонецЕсли;
		
		// If syntax error Тогда exit. */
		Если (Result = define.LALRSYNTAXERROR) Тогда
			// Return LALR state in the Token.СимволРазбора. */
			ТекТокен.Token.СимволРазбора = СостояниеРазбора;
			Возврат define.PARSESYNTAXERROR;
		КонецЕсли;
		
		// Exit Если the LALR state machine says it has reached it's exit.
		Если (Result = define.LALRACCEPT) Тогда
			Токен = СтекТокенов.Token;
			Возврат define.PARSEACCEPT;
		КонецЕсли;
		
		// Push the token onto the СтекТокенов. */
		ТекТокен.Token.СтрокаКомментария = СтрокаКомментария;
		ТекТокен.СледующийТокен = СтекТокенов;
		СтекТокенов = ТекТокен;
		СтрокаКомментария = "";
	КонецЦикла;
	
	ВызватьИсключение "Сюда попасть невозможно!!! Как вы этого добились?";
КонецФункции



Функция ShowIndent(size=0)
	result= "";
	Для i =1 to size Цикл
		result = result + " ";
	КонецЦикла;
	return result;
КонецФункции


Функция Преобразовать(СтруктураГраматики,Токен,Indent,Отладка,Оптимизировать)
	var i;
	правило = СтруктураГраматики.Переходы.Таблица[Токен.ReductionRule];

	if (Отладка) then
		message(ShowIndent(Indent)+"Преобразовываем правило: "+СтруктураГраматики.Правила[Токен.ReductionRule].Описание);
	endif;
	
	
	имяПравила = СтруктураГраматики.Правила[Токен.ReductionRule].Имя;
	объект = Новый Структура;
	объект.Вставить("ast_id",getId());
	объект.Вставить("name",имяПравила);
	объект.Вставить("ruleId",правило.Индекс);
	объект.Вставить("description",СтруктураГраматики.Правила[Токен.ReductionRule].Описание);
	// ITG
	объект.Вставить("lexems", Новый Массив);

	countData = 0;
	Для each x in Токен.Tokens Цикл
		if x = undefined then
			continue;
		endif;
		countData = countData + 1;
		name = СтруктураГраматики.Символы[x.СимволРазбора].Имя;
		if (x.ReductionRule < 0) then
			если СтруктураГраматики.Символы[x.СимволРазбора].Исключаемый и ПараметрыРаботы.СкрыватьСимволы тогда
				continue;
			КонецЕсли;
			токенВставки = Новый Структура;
			токенВставки.Вставить("ast_id",getId());
			токенВставки.Вставить("Data",x.Data);
			токенВставки.Вставить("line",x.СтрокаТокена);
			токенВставки.Вставить("column",x.КолонкаТокена);
			токенВставки.Вставить("symbol",x.СимволРазбора);
			// ITG
			токенВставки.Вставить("name",name);
			Если не ПустаяСтрока(x.СтрокаКомментария) и ПараметрыРаботы.СохранятьКомментарии Тогда
				токенВставки.Вставить("commentString",x.СтрокаКомментария);
			КонецЕсли; 
			//объект.Вставить(Модификатор()+name,токенВставки);
			// заменить вставку в структуру на вставку в массив, потому как мне важен порядок лексем
			// и допускается множественное применение одних и тех же лексем
			// ITG
			объект.lexems.Добавить(токенВставки);
			
			if (Отладка > 0) then
				message(ShowIndent(Indent + 1)+"Token["+i+"] = СимволРазбора('"+СтруктураГраматики.Символы[x.СимволРазбора].Имя+"') = '"+x.Data+"'");
			endif;
		else
			// It's a rule. */
			// Debugging: show a description of the rule. */
			if (Отладка> 0) then
				message(ShowIndent(Indent + 1)+"Token["+i+"] = Rule = "+СтруктураГраматики.Правила[x.ReductionRule].Описание);
			endif;
			Indent = Indent + 1;
			//Объект.Вставить(name,Преобразовать(СтруктураГраматики,x,Indent,Отладка,Оптимизировать));
			// заменить вставку в структуру на вставку в массив, потому как мне важен порядок лексем
			// и допускается множественное применение одних и тех же лексем
			// ITG
			объект.lexems.Добавить(Преобразовать(СтруктураГраматики,x,Indent,Отладка,Оптимизировать));
			
			if (Отладка) then
				message(ShowIndent(Indent + 2)+"Result value = "+Объект.name);
			endif;
		endif;
	КонецЦикла;
	
	Возврат объект;
КонецФункции


Функция ПреобразоватьВМассив(вхСтрока)
	массивСимволов = новый Массив;
	для х = 1 по СтрДлина(вхСтрока) цикл
		массивСимволов.Добавить(CharCode(Сред(вхСтрока,х,1)));
	КонецЦикла;
	Возврат массивСимволов;
КонецФункции


Функция РазобратьСтрокуАвтоматом(ТекстРазбора,СтруктураГраматики)  экспорт
	перем СтартовыйСимвол;
	МассивРазбора = ПреобразоватьВМассив(ТекстРазбора);
	Результат = Разобрать(СтруктураГраматики,МассивРазбора,МассивРазбора.Количество(),ПараметрыРаботы.Оптимизировать,ПараметрыРаботы.Отладка,СтартовыйСимвол);
	// Interpret the results. */
	Если (Результат <> define.PARSEACCEPT) Тогда
		ВызватьИсключение "Ерунда при разборе. Го в отладчик, посоны!!!";
	else
		Результат = Преобразовать(СтруктураГраматики,СтартовыйСимвол,1,ПараметрыРаботы.Отладка,ПараметрыРаботы.Оптимизировать);
	КонецЕсли;
	// Cleanup.
	Возврат Результат;
КонецФункции

define = new Structure;
define.Insert("PARSEACCEPT",0);         // Input parsed, no errors.
define.Insert("PARSELEXICALERROR",1);   // Input could not be tokenized.
define.Insert("PARSETOKENERROR",2);     // Input is an invalid token.
define.Insert("PARSESYNTAXERROR",3);    // Input Циклes not match any rule.
define.Insert("PARSECOMMENTERROR",4);   // A comment was started but not finished.
define.Insert("PARSEMEMORYERROR",5);    // Insufficient memory.
// СимволРазбораStruct types (defined by GOLD).
define.Insert("SYMBOLNONTERMINAL",0);
define.Insert("SYMBOLTERMINAL",1);
define.Insert("SYMBOLWHITESPACE",2);
define.Insert("SYMBOLEOF",3);
define.Insert("SYMBOLCOMMENTSTART",4);
define.Insert("SYMBOLCOMMENTEND",5);
define.Insert("SYMBOLCOMMENTLINE",6);
define.Insert("SYMBOLERROR",7);
// ActionStruct types (defined by GOLD).
define.Insert("ACTIONSHIFT",1);
define.Insert("ACTIONREDUCE",2);
define.Insert("ACTIONGOTO",3);
define.Insert("ACTIONACCEPT",4);
// CaseSensitive values (defined by GOLD).
define.Insert("False",0);
define.Insert("True",1);

define.Insert("LALRMEMORYERROR",0);
define.Insert("LALRSYNTAXERROR",1);
define.Insert("LALRACCEPT",2);
define.Insert("LALRSHIFT",3);
define.Insert("LALRGOTO",4);

id = 0;
	
	